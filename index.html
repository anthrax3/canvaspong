<html>

  <head>

    <title>Canvas Pong</title>

    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
        font-size: 10px;
        line-height: 1em;
        background: #eee; 
      }
      #canvas {
        position: fixed;
        width: 100%;
        height: 100%;
      }
      #twitter {
        position: fixed;
        bottom: 30px;
        left: 20px;
        font-size: 42px;
      }
      a, a:visited {
        color: blue;
        text-decoration: none;
      }
    </style>

  </head>

  <body>

    <canvas id="canvas">
      upgrade yo shit
    </canvas>

    <div id="twitter">
      <a href="http://twitter.com/seejohnrun">@seejohnrun on twitter</a>
    </div>

    <script>
      // TODO make the page unable to scroll after its over
      // TODO keep score on the screen
      // TODO beautify
      // TODO arrow to describe the game
      // TODO doctype
      // TODO make 'update yo shit' be something real
      // TODO don't clear the paddle so aggressively
      // TODO don't hard code paddle xPos in ball#draw
      // DONETODO don't let the paddle descent off the screen
      // DONETODO cleaner hits
      // DONETODO put the ball in the center and have it decide which way to go
      // DONETODO give them the same size paddle as us
      // DONETODO other paddle
      // DONETODO click to start
      // DONETODO twitter link
      // DONETODO clean up all the messy code
      // DONETODO only clear what needs to clear
      // DONETODO change name of circle size to radius
      // DONETODO make it possible to start off going in the POSITIVE y as well
    </script>

    <script type="text/javascript">

      function Paddle(context, ball, paddleHeight) {

        // Load the canvas and context
        this.$canvas = context.canvas;
        this.context = context;

        // The ball we are trying to track
        this.ball = ball;

        // Dimensions and colors
        this.paddleWidth = 20;
        this.paddleHeight = paddleHeight;
        this.fillColor = 'blue';
        this.strokeColor = '#000';

        // The X position never changes
        this.xPos = 0;

        // The speed the paddle can move - never changes
        this.ySpeed = 4; // slightly slower than the ball

        // Get the paddle ready to go - by default the paddle starts in the center of the screen
        this.reset = function() {
          this.yPos = document.body.clientHeight / 2 - this.paddleHeight / 2;
        }

        // Draw the rectangular paddle into the given context
        this.draw = function() {
          this.context.fillStyle = this.fillColor;
          this.context.strokeStyle = this.strokeColor;
          this.context.fillRect(this.xPos, this.yPos, this.paddleWidth - 2, this.paddleHeight - 2); // account for stroke
          this.context.stroke();
        }

        // Move the paddle one step, and keep in mind that the screen has upper and lower bounds
        // that the paddle can't cross.
        // Singular argument is the distance to the desired target
        this.edgeMove = function(distance) {
          if (distance < 0) {
            if (this.yPos > 0) this.yPos += -this.ySpeed;
          }
          else {
            if (this.yPos + this.paddleHeight < document.body.clientHeight) this.yPos += this.ySpeed;
          }
        }

        // Move the paddle to attempt to make its center even with the ball.  Limited by a max speed
        // When the ball is headed away from the paddle, move to center to wait
        this.move = function() {
          if (ball.xSpeed < 0) {
            var distance = this.ball.yPos - (this.yPos + this.paddleHeight / 2);
            this.edgeMove(distance);
          }
          else {
            var distance = document.body.clientHeight / 2 - (this.yPos + this.paddleHeight / 2);
            if (Math.abs(distance) >= this.ySpeed) this.edgeMove(distance); // no jitter
          }
        }

        // Clear from the last place we were.  The reason we clear larger than needed is to cover
        // ordering of clears for performance reasons to avoid flicker
        this.clear = function() {
          this.context.clearRect(this.xPos, 0, this.paddleWidth, document.body.clientHeight);
        }

        this.reset();

      }

      function Ball(context) {

        // Load the canvas and context
        this.$canvas = context.canvas;
        this.context = context;

        // This is the radius of the circle
        this.circleRadius = 10;
        this.fillColor = '#555';
        this.strokeColor = '#000';

        // This is to set up to a neutral place to get ready to start playing
        this.reset = function() {
          // Clear the ball away from where it was
          this.clear();
          // This is the xSpeed of the ball, which will be added to the xPos on each iteration
          // Initially, they are decided as either positive or negative
          this.xSpeed = Math.random() > 0.5 ? 5 : -5;
          this.ySpeed = Math.random() > 0.5 ? 5 : -5;
          // This is the xPosition of the ball
          this.xPos = document.body.clientWidth / 2;
          // This is the yPosition of the ball
          // initially dynamically decided randomly
          this.yPos = Math.floor(Math.random() * document.body.clientHeight);
        }

        // Draw the ball in the given context
        this.draw = function() {
          this.context.fillStyle = this.fillColor;
          this.context.strokeStyle = this.strokeColor;

          this.context.beginPath();
          this.context.arc(this.xPos, this.yPos, this.circleRadius - 1, 0, Math.PI * 2, true); // leave room for the stroke
          this.context.closePath();
          this.context.fill();
          this.context.stroke();
        }

        // This will clear the ball from the given context
        this.clear = function() {
          this.context.clearRect(this.xPos - this.circleRadius, this.yPos - this.circleRadius, this.circleRadius * 2, this.circleRadius * 2);
        }

        // This will clear the move of the ball from the given context
        // The reason we clear last instead of clearing current is for performance to reduce flicker on computation
        // for slow machines
        this.clearLast = function() {
          this.context.clearRect(this.xPos - this.xSpeed - this.circleRadius, this.yPos - this.ySpeed - this.circleRadius, this.circleRadius * 2, this.circleRadius * 2);
        }

        // Make the next move for the ball
        this.move = function(hitterFrom, hitterTo) {  
          // Move horizontally
          if ((this.xPos > this.$canvas.width - this.circleRadius) || (this.xPos < 20)) this.xSpeed = -this.xSpeed;
          this.xPos += this.xSpeed;
          // And vertically
          if ((this.yPos > this.$canvas.height - this.circleRadius) || (this.yPos < this.circleRadius)) this.ySpeed = -this.ySpeed;
          this.yPos += this.ySpeed;
        }

        this.reset();

      }

      // settings
      var difficulty = 3;
      var fps = 100;

      // get the space
      document.body.style.height = document.body.clientHeight * difficulty;

      // get the hitter height - cH^2/sH
      var hitterHeight = Math.pow(document.body.clientHeight, 2) / document.body.scrollHeight;

      // get the canvas
      var $canvas = document.getElementById('canvas');
      $canvas.width = document.body.clientWidth;
      $canvas.height = document.body.clientHeight;
      var context = $canvas.getContext('2d');

      // Get a ball
      var ball = new Ball(context);
      var paddle = new Paddle(context, ball, hitterHeight);

      window.onmouseup = function() {

        // Reset the ball after each game
        ball.clearLast();
        ball.reset();

        // Set the background to a non-error color
        document.body.style.background = '#eee';
     
        // Keep it moving, bro
        var interval = setInterval(function() {

          // If we're on the right side, consider that the user may have just lost
          if (ball.xPos >= $canvas.width - ball.circleRadius) {
            // Determine the position of the hittern and break on a match
            // Since this is scrollTop we need to offset it by clientHeight
            // NOTE: position represents the TOP of the hitter
            var position = (document.body.scrollTop / document.body.scrollHeight) * document.body.clientHeight;
            if (ball.yPos < position || ball.yPos > position + hitterHeight) {
              document.body.style.background = '#660000';
              clearInterval(interval);
              return; // stop moving
            }
          }

          // If we're at the edge of the paddle, consider that it may not have gotten reflected
          if (ball.xPos <= 20) {
            if (ball.yPos < paddle.yPos || ball.yPos > paddle.yPos + paddle.paddleHeight) {
              document.body.style.background = '#006600';
              clearInterval(interval);
              return; // stop moving
            }
          }

          // Move the paddle and draw it - paddle is at a disadvantage cause its first
          paddle.move();
          paddle.clear();
          paddle.draw();

          // Move the ball and draw it
          ball.move();
          ball.clearLast();
          ball.draw();

        }, 1000 / fps);

      }

    </script>

  </body>

</html>
