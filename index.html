<html>

  <head>

    <title>Canvas Pong</title>

    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
        font-size: 10px;
        line-height: 1em;
        background: #eee; 
      }
      #canvas {
        position: fixed;
        width: 100%;
        height: 100%;
      }
      #twitter {
        position: fixed;
        bottom: 30px;
        left: 30px;
        font-size: 42px;
      }
      a, a:visited {
        color: blue;
        text-decoration: none;
      }
      #score {
        position: fixed;
        bottom: 30px;
        right: 30px;
        font-size: 42px;
      }
      #intro {
        font-size: 24px;
        position: fixed;
        top: 30px;
        left: 30px;
        width: 400px;
        line-height: 1em;
        text-align: left;
      }
    </style>

  </head>

  <body>

    <canvas id="canvas">
      This page is built using a <a href=''>HTML5 <code>&lt;canvas&gt;</code> tag.</a>
      Unfortunately, it looks like your browser doesn't support that.
      Maybe you should upgrade to <a href=''>Chrome</a> or <a href=''>Firefox</a>.
    </canvas>

    <div id="twitter">
      <a href="http://twitter.com/seejohnrun">@seejohnrun on twitter</a>
    </div>

    <div id="intro">
      HTML5 <code>&lt;canvas&gt;</code> is all the rage these days.
      This pong game uses your scrollbar as the paddle.  Click to start!
    </div>

    <div id="score"></div>

    <script>
      // TODO make the page unable to scroll after its over
      // TODO beautify
      // TODO doctype
      // TODO paddle hits cleaner - one idea is to shrink the size of the canvas horizontally
      // TODO get real links for things
      // DONETODO describe the game
      // DONETODO make 'update yo shit' be something real
      // DONETODO don't hard code paddle xPos in ball#draw
      // DONETODO fix the stroke clearing issue after the game stops
      // DONETODO keep score on the screen
      // DONETODO don't clear the paddle so aggressively
      // DONETODO don't let the paddle descent off the screen
      // DONETODO cleaner hits
      // DONETODO put the ball in the center and have it decide which way to go
      // DONETODO give them the same size paddle as us
      // DONETODO other paddle
      // DONETODO click to start
      // DONETODO twitter link
      // DONETODO clean up all the messy code
      // DONETODO only clear what needs to clear
      // DONETODO change name of circle size to radius
      // DONETODO make it possible to start off going in the POSITIVE y as well
    </script>

    <script type="text/javascript">

      function Paddle(context, paddleHeight) {

        // Load the canvas and context
        this.$canvas = context.canvas;
        this.context = context;

        // Dimensions and colors
        this.paddleWidth = 20;
        this.paddleHeight = paddleHeight;
        this.fillColor = 'blue';

        // The X position never changes
        // keep this guy on the left edge of the screen
        this.xPos = 0;

        // The speed the paddle can move - never changes
        this.ySpeed = 4; // slightly slower than the ball

        // Get the paddle ready to go - by default the paddle starts in the center of the screen
        this.reset = function() {
          this.yPos = document.body.clientHeight / 2 - this.paddleHeight / 2;
        }

        // Draw the rectangular paddle into the given context
        this.draw = function() {
          this.context.fillStyle = this.fillColor;
          this.context.fillRect(this.xPos, this.yPos, this.paddleWidth, this.paddleHeight);
        }

        // The horizontal position of the right side of the paddle
        this.right = function() {
          return this.paddleWidth + this.xPos;
        }

        // The vertical position of the top of the paddle
        this.top = function() {
          return this.yPos;
        }

        // The vertical position of the bottom of the paddle
        this.bottom = function() {
          return this.yPos + this.paddleHeight;
        }

        // Move the paddle one step, and keep in mind that the screen has upper and lower bounds
        // that the paddle can't cross.
        // Singular argument is the distance to the desired target
        this.edgeMove = function(distance) {
          if (distance < 0) {
            if (this.top() > 0) this.yPos += -this.ySpeed;
          }
          else {
            if (this.bottom() < document.body.clientHeight) this.yPos += this.ySpeed;
          }
        }

        // Move the paddle to attempt to make its center even with the ball.  Limited by a max speed
        // When the ball is headed away from the paddle, move to center to wait
        this.move = function(ball) {
          if (ball.xSpeed < 0) {
            var distance = ball.yPos - (this.yPos + this.paddleHeight / 2);
            this.edgeMove(distance);
          }
          else {
            var distance = document.body.clientHeight / 2 - (this.yPos + this.paddleHeight / 2);
            if (Math.abs(distance) >= this.ySpeed) this.edgeMove(distance); // no jitter
          }
        }

        // Clear from the last place we were.
        // ordering of clears for performance reasons to avoid flicker
        this.clear = function() {
          // offset of one for the stroke
          this.context.clearRect(this.xPos, this.yPos - this.ySpeed, this.paddleWidth, this.paddleHeight + this.ySpeed * 2);
        }

        this.reset();

      }

      function Ball(context, leftEdge) {

        // Load the canvas and context
        this.$canvas = context.canvas;
        this.context = context;

        // Where the edge is
        this.leftEdge = leftEdge;

        // This is the radius of the circle
        this.circleRadius = 10;
        this.fillColor = '#555';

        // This is to set up to a neutral place to get ready to start playing
        this.reset = function() {
          // Clear the ball away from where it was
          this.clear();
          // This is the xSpeed of the ball, which will be added to the xPos on each iteration
          // Initially, they are decided as either positive or negative
          this.xSpeed = Math.random() > 0.5 ? 5 : -5;
          this.ySpeed = Math.random() > 0.5 ? 5 : -5;
          // This is the xPosition of the ball
          this.xPos = document.body.clientWidth / 2;
          // This is the yPosition of the ball
          // initially dynamically decided randomly
          this.yPos = Math.floor(Math.random() * document.body.clientHeight);
        }

        // Draw the ball in the given context
        this.draw = function() {
          this.context.fillStyle = this.fillColor;

          this.context.beginPath();
          this.context.arc(this.xPos, this.yPos, this.circleRadius, 0, Math.PI * 2, true);
          this.context.closePath();
          this.context.fill();
        }

        // The vertical position of the top of the ball
        this.top = function() {
          return this.yPos - this.circleRadius;
        }

        // The horizontal position of the left of the ball
        this.left = function() {
          return this.xPos - this.circleRadius;
        }

        // The vertical position of the bottom of the ball
        this.bottom = function() {
          return this.yPos + this.circleRadius;
        }

        // The horizontal position of the right of the ball
        this.right = function() {
          return this.xPos + this.circleRadius;
        }

        // This will clear the ball from the given context
        this.clear = function() {
          this.context.clearRect(this.left(), this.top(), this.circleRadius * 2, this.circleRadius * 2);
        }

        // This will clear the move of the ball from the given context
        // The reason we clear last instead of clearing current is for performance to reduce flicker on computation
        // for slow machines
        this.clearLast = function() {
          this.context.clearRect(this.left() - this.xSpeed, this.top() - this.ySpeed, this.circleRadius * 2, this.circleRadius * 2);
        }

        // Make the next move for the ball
        this.move = function(hitterFrom, hitterTo) {  
          // Move horizontally
          if ((this.xPos >= this.$canvas.width - this.circleRadius) || (this.xPos <= leftEdge)) this.xSpeed = -this.xSpeed;
          this.xPos += this.xSpeed;
          // And vertically
          if ((this.yPos >= this.$canvas.height - this.circleRadius) || (this.yPos <= this.circleRadius)) this.ySpeed = -this.ySpeed;
          this.yPos += this.ySpeed;
        }

      }

      // settings
      var difficulty = 4;
      var fps = 100;

      // get the space
      document.body.style.height = document.body.clientHeight * difficulty;

      // get the hitter height - cH^2/sH
      var hitterHeight = Math.pow(document.body.clientHeight, 2) / document.body.scrollHeight;

      // get the canvas
      var $canvas = document.getElementById('canvas');
      $canvas.width = document.body.clientWidth;
      $canvas.height = document.body.clientHeight;
      var context = $canvas.getContext('2d');

      // Get a ball and paddle
      var paddle = new Paddle(context, hitterHeight);
      var ball = new Ball(context, paddle.right());

      // keep score
      var theirScore = 0;
      var yourScore = 0;

      window.onmouseup = function() {

        // remove the intro box
        var $intro = document.getElementById('intro');
        $intro.style.display = 'none';

        // Reset the ball before each game
        ball.clear();
        ball.reset();

        // Set the background to a non-error color
        document.body.style.background = '#eee';
     
        // Keep it moving, bro
        var interval = setInterval(function() {

          // Move the paddle and ball - paddle is at a disadvantage cause its first
          paddle.move(ball);
          ball.move();

          // Draw the screen, clearing previous moves
          ball.clearLast();
          ball.draw();
          paddle.clear();
          paddle.draw();

          // If we're on the right side, consider that the user may have just lost
          if (ball.xPos >= $canvas.width - ball.circleRadius) {
            // Determine the position of the hittern and break on a match
            // Since this is scrollTop we need to offset it by clientHeight
            // NOTE: position represents the TOP of the hitter
            var position = (document.body.scrollTop / document.body.scrollHeight) * document.body.clientHeight;
            if (ball.bottom() < position || ball.top() > position + hitterHeight) {
              document.body.style.background = '#ee7777';
              document.getElementById('score').innerHTML = (theirScore += 1) + ' / ' + yourScore;
              clearInterval(interval);
            }
          }

          // If we're at the edge of the paddle, consider that it may not have gotten reflected
          if (ball.xPos <= paddle.right()) {
            if (ball.bottom() < paddle.top() || ball.top() > paddle.bottom()) {
              document.body.style.background = '#77ee77';
              document.getElementById('score').innerHTML = theirScore + ' / ' + (yourScore += 1);
              clearInterval(interval);
            }
          }

        }, 1000 / fps);

      }

    </script>

  </body>

</html>
